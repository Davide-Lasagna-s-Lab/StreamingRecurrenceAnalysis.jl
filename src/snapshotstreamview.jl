export snapshot_stream_view, _step!

# This cannot be a subtype of AbstractVector, because its elements are 
# inherently sequential.
mutable struct SnapshotStreamView{T, G}
         g::G         # the forward map
    buffer::Vector{T} # buffer with snapshots
         N::Int       # number of snapshots produced
    function SnapshotStreamView{T, G}(g, buffer::Vector{T}, N::Int) where {T, G}
        N ≥ length(buffer) - 1 ||
            throw(ArgumentError("length of snapshot stream must be higher than buffer width"))
        return new(g, buffer, N)
    end
end

"""
    snapshot_stream_view(g, x₀::T, width::Int, N::Int)

Construct a view over a stream of snapshots, starting from an initial condition
`x₀` and generated by the forward map operator `g`. The map `g` is supposed to 
work in-place. The view is a vector with elements of type `T` and length `width`. 
The snapshot stream terminates after `N` elements have beeen generated. The
"""
snapshot_stream_view(g, x₀::T, width::Int, N::Int) where {T} = 
    (buffer = T[similar(x₀) for i = 1:width]; buffer[1] .= x₀;
     return SnapshotStreamView{T, typeof(g)}(g, buffer, N))

# ~~~ Iteration Protocol ~~~
function Base.start(s::SnapshotStreamView)
    # fill all buffer except one element
    for i = 1:length(s.buffer) - 2
        _step!(s)
    end
    return length(s.buffer) - 2
end

Base.next(s::SnapshotStreamView, state) = (_step!(s), state+=1)
Base.done(s::SnapshotStreamView, state) = state == s.N

# advance time and return buffer
function _step!(s::SnapshotStreamView)
    # copy current state `buffer[1]` to storage that will be overwritten
    s.buffer[end] .= s.buffer[1]

    # remove last, advance in time, then insert at the beginning
    insert!(s.buffer, 1, s.g(pop!(s.buffer)))
end

# number of views returned
Base.length(s::SnapshotStreamView) = s.N - 1