export streamview, _step!, StreamView

# This is not <: AbstractVector, because its elements might be sequential.
struct StreamView{X, G}
         g::G         # the forward map
    buffer::Vector{X} # buffer with snapshots
         N::Int       # number of snapshots produced
end

"""
    streamview(g, x₀::X, width::Int, N::Int)

Construct a view over a stream of snapshots, starting from an initial condition
`x₀` and generated by the forward map operator `g : X → X` . The map `g` works
in-place. The view is a vector with elements of type `X` and length `width`.
The snapshot stream terminates after `N` snapshots have been generated.
"""
function streamview(g, x₀::X, width::Int, N::Int) where {X}
    N ≥ width - 1 ||
        throw(ArgumentError("length of snapshot stream must be " *
                            "higher than buffer width"))
    width > 0 ||
        throw(ArgumentError("width must be positive, got $width"))    
    buffer = X[zero(x₀) for i = 1:width]
    buffer[end] .= x₀
    StreamView(g, buffer, N)
end

# ~~~ Iteration Protocol ~~~
@inline function Base.start(s::StreamView)
    # fill all buffer minus the first and the last
    for i = 1:length(s.buffer) - 2
        _step!(s)
    end
    return length(s.buffer) - 2
end

# handle the width = 1 case
@inline Base.next(s::StreamView{X}, state) where {X} =
    (state < 0 ? s.buffer : _step!(s), state+=1)

@inline Base.done(s::StreamView, state) = state == s.N

# advance time and return buffer
@inline function _step!(s::StreamView)
    # copy current state `buffer[1]` to storage that will be overwritten
    @inbounds s.buffer[1] .= s.buffer[end]

    # remove last, advance in time, then insert at the beginning
    insert!(s.buffer, length(s.buffer), s.g(shift!(s.buffer)))
end

# width of the view
width(s::StreamView) = length(s.buffer)

# number of views returned
Base.length(s::StreamView) = s.N - length(s.buffer) + 2
Base.eltype(s::StreamView{X}) where {X} = Vector{X}